! XSUM_KERNELS
!
! USAGE
!   bin/xsum_kernels INPUT_FILE OUTPUT_FILE
!
!
! COMMAND LINE ARGUMENTS
!   INPUT_FILE             - text file containing list of kernel directories
!   OUTPUT_PATH            - directory to which summed kernels are written
!
!
! DESCRIPTION
!   Sums kernels from directories specified in INPUT_FILE.
!   Writes the resulting sums to OUTPUT_FILE.
!
!   INPUT_FILE is a text file containing a list of absolute or relative paths to
!   kernel directories, one directory per line. Each kernel directory must
!   contain the following ASCII files, which are generated by SPECFEM2D when
!   adjoint simulation is run and save ascii kernels option is specified:
!
!     proc000000_rhop_alpha_beta_kernel.dat
!     proc000000_rho_kappa_mu.dat
!


program sum_kernels

  implicit none

  integer, parameter :: MAX_KERNEL_PATHS = 65535
  integer, parameter :: MAX_STRING_LEN = 255

  integer, parameter :: IIN = 101
  integer, parameter :: IOUT = 102

  integer :: ipath, npath, iker, nline, i,j
  double precision, allocatable, dimension(:) :: kernel1, kernel2, kernel3
  double precision, allocatable, dimension(:) :: kernel_sum1, kernel_sum2, kernel_sum3
  double precision, allocatable, dimension(:) :: xcoord, zcoord
  character(len=MAX_STRING_LEN) :: input_file, output_file
  character(len=MAX_STRING_LEN) :: kernel_paths(MAX_KERNEL_PATHS), kernel_path
  character(len=MAX_STRING_LEN) :: dir, filename, arg(2), line
  integer :: ios, ier
  double precision :: dummy1, dummy2

  print *, 'Running XSUM_KERNELS'
  print *,

  ! parse command line arguments
  do i = 1, 2
    call get_command_argument(i,arg(i), status=ier)
    if (i <= 1 .and. trim(arg(i)) == '') then
      print *, 'USAGE: bin/xsum_kernels INPUT_FILE OUTPUT_FILE'
      print *, ''
      stop 'Please check command line arguments'
    endif
  enddo

  read(arg(1),'(a)') input_file
  read(arg(2),'(a)') output_file

  ! parse paths from INPUT_FILE
  npath=0
  open(unit = IIN, file = trim(input_file), status = 'old',iostat = ier)
  if (ier /= 0) then
     print *,'Error opening ',trim(input_file)
     stop 'Please check command line argument: INPUT_FILE'
  endif
  do while (1 == 1)
     read(IIN,'(a)',iostat=ier) line
     if (ier /= 0) exit
     npath = npath+1
     if (npath > MAX_KERNEL_PATHS) stop 'Error number of paths exceeds MAX_KERNEL_PATHS'
     kernel_paths(npath) = trim(line)
  enddo
  close(IIN)
  print *, 'Number of paths: ', npath
  print *,

  call get_number_gll_points(kernel_paths(1), nline)
  print *, 'Number of lines: ', nline
  print *,

  allocate( kernel1(nline) )
  allocate( kernel2(nline) )
  allocate( kernel3(nline) )
  allocate( kernel_sum1(nline) )
  allocate( kernel_sum2(nline) )
  allocate( kernel_sum3(nline) )
  kernel1(:) = 0.0d0
  kernel2(:) = 0.0d0
  kernel3(:) = 0.0d0
  kernel_sum1(:) = 0.0d0
  kernel_sum2(:) = 0.0d0
  kernel_sum3(:) = 0.0d0

  allocate( xcoord(nline) )
  allocate( zcoord(nline) )
  call get_coordinates(kernel_paths(1), nline, xcoord, zcoord)


  ! sum kernels
  do ipath = 1, npath
     open(unit=IIN,file=trim(kernel_paths(ipath)), status='old', action='read')
     do j = 1,nline
        read(IIN,*) dummy1, dummy2, kernel1(j), kernel2(j), kernel3(j)
     enddo
     close(IIN)

     if (ipath == 1) then
        kernel_sum1 = kernel1
        kernel_sum2 = kernel2
        kernel_sum3 = kernel3
     else
       kernel_sum1(:)=kernel_sum1(:)+kernel1(:)
       kernel_sum2(:)=kernel_sum2(:)+kernel2(:)
       kernel_sum3(:)=kernel_sum3(:)+kernel3(:)
     endif
  enddo

  ! save result
  print *, 'Writing kernels to: ', trim(output_file)
  print *,

  open(unit=IOUT,file=trim(output_file),status='unknown',action='write')
  do j = 1, nline
        write(IOUT,'(5e12.3)') xcoord(j),zcoord(j),kernel_sum1(j),kernel_sum2(j),kernel_sum3(j)
  enddo
  close(IOUT)


  print *, 'Finished writing kernels '
  print *,

end program sum_kernels


! ------------------------------------------------------------------------------

subroutine get_number_gll_points(kernel_path, nline)

  integer, parameter :: MAX_STRING_LEN = 255
  integer, parameter :: MAX_NUMBER_LINES = 2147483647

  integer, parameter :: IIN = 101

  double precision :: dummy1, dummy2, dummy3, dummy4, dummy5

  character(len=MAX_STRING_LEN) :: kernel_path

  integer :: ios, nline

  open(unit=IIN,file=trim(kernel_path),status='old',action='read')
  nline = 0
  do j=1,MAX_NUMBER_LINES
     read(IIN,*,iostat=ios) dummy1, dummy2, dummy3, dummy4, dummy5
     if (ios /= 0) exit
     nline=nline+1
  enddo
  close(IIN)

end subroutine get_number_gll_points


! ------------------------------------------------------------------------------

subroutine get_coordinates(kernel_path, nline, xcoord, zcoord)

  integer, parameter :: MAX_STRING_LEN = 255

  integer, parameter :: IIN = 101

  double precision :: xcoord(nline), zcoord(nline)

  double precision :: dummy1, dummy2, dummy3

  character(len=MAX_STRING_LEN) :: kernel_path

  xcoord(:) = 0.d0
  zcoord(:) = 0.d0

  open(unit=IIN,file=trim(kernel_path),status='old',action='read')
  do j=1,nline
     read(IIN,*) xcoord(j), zcoord(j), dummy1, dummy2, dummy3
  enddo
  close(IIN)

end subroutine get_coordinates

